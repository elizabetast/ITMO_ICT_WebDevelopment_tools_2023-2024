{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"LR1/","text":"Models Book instance class BookInstanceBase(SQLModel): book_id: Optional[int] = Field(default=None, foreign_key=\"book.id\") date: datetime.datetime publisher: str features: str class BookInstance(BookInstanceBase, table=True): id: int = Field(default=None, primary_key=True) owner_id: Optional[int] = Field(default=None, foreign_key=\"user.id\") requests: Optional[List[\"BookExchange\"]] = Relationship( back_populates=\"book_instance\", sa_relationship_kwargs=dict(foreign_keys=\"[BookExchange.book_instance_id]\"), ) book: Optional[\"Book\"] = Relationship(back_populates=\"instances\") owner: Optional[\"User\"] = Relationship(back_populates=\"instances\") class BookInstanceRead(BookInstanceBase): id: int owner_id: int class BookInstanceWithBook(BookInstanceRead): book: \"BookRead\" = None class BookInstanceReadFull(BookInstanceWithBook): requests: list[\"BookExchangeRead\"] = [] owner: \"UserBase\" = None Author class AuthorBase(SQLModel): name: str bio: str class Author(AuthorBase, table=True): id: int = Field(default=None, primary_key=True) books: Optional[List[\"Book\"]] = Relationship(back_populates=\"author\") class AuthorRead(AuthorBase): id: int class AuthorReadFull(AuthorRead): books: list[\"BookRead\"] = [] Book class BookBase(SQLModel): title: str description: str author_id: Optional[int] = Field(default=None, foreign_key=\"author.id\") class Book(BookBase, table=True): id: int = Field(default=None, primary_key=True) author: Optional[Author] = Relationship(back_populates=\"books\") owners: Optional[List[\"User\"]] = Relationship(back_populates=\"books\", link_model=BookInstance) instances: Optional[List[\"BookInstance\"]] = Relationship(back_populates=\"book\") class BookRead(BookBase): id: int class BookReadFull(BookRead): author: AuthorRead = None owners: list[\"UserBase\"] = [] instances: list[\"BookInstanceRead\"] = [] User class UserBase(SQLModel): id: int = Field(primary_key=True) username: str = Field(index=True) name: str about: str email: EmailStr = Field(unique=True, index=True, sa_type=AutoString) class User(UserBase, table=True): password: str = Field(max_length=256, min_length=6) created_at: datetime.datetime = datetime.datetime.now() books: Optional[List[\"Book\"]] = Relationship(back_populates=\"owners\", link_model=BookInstance) sender_requests: Optional[List[\"BookExchange\"]] = Relationship( back_populates=\"sender\", sa_relationship_kwargs=dict(foreign_keys=\"[BookExchange.sender_id]\"), ) receiver_requests: Optional[List[\"BookExchange\"]] = Relationship( back_populates=\"receiver\", sa_relationship_kwargs=dict(foreign_keys=\"[BookExchange.receiver_id]\"), ) instances: Optional[List[\"BookInstance\"]] = Relationship(back_populates=\"owner\") class UserReadFull(UserBase): sender_requests: list[\"BookExchangeRead\"] = [] receiver_requests: list[\"BookExchangeRead\"] = [] instances: list[\"BookInstanceWithBook\"] = [] class UserInput(SQLModel): name: str about: str username: str password: str = Field(max_length=256, min_length=6) password2: str email: EmailStr = Field(unique=True, index=True, sa_type=AutoString) @validator('password2') def password_match(cls, v, values, **kwargs): if 'password' in values and v != values['password']: raise ValueError('passwords don\\'t match') return v class UserLogin(SQLModel): username: str password: str class UserPassword(SQLModel): old_password: str new_password: str Book exchange class BookExchangeBase(SQLModel): book_instance_id: Optional[int] = Field(default=None, foreign_key=\"bookinstance.id\") status: ExchangeStatus date_start: datetime.datetime date_end: datetime.datetime class BookExchange(BookExchangeBase, table=True): id: int = Field(default=None, primary_key=True) sender_id: Optional[int] = Field(default=None, foreign_key=\"user.id\") receiver_id: Optional[int] = Field(default=None, foreign_key=\"user.id\") sender: Optional[\"User\"] = Relationship( back_populates=\"sender_requests\", sa_relationship_kwargs=dict(foreign_keys=\"[BookExchange.sender_id]\"), ) receiver: Optional[\"User\"] = Relationship( back_populates=\"receiver_requests\", sa_relationship_kwargs=dict(foreign_keys=\"[BookExchange.receiver_id]\"), ) book_instance: Optional[\"BookInstance\"] = Relationship( back_populates=\"requests\", sa_relationship_kwargs=dict(foreign_keys=\"[BookExchange.book_instance_id]\"), ) class BookExchangeChangeStatus(SQLModel): status: ExchangeStatus class BookExchangeRead(BookExchangeBase): id: int sender_id: int receiver_id: int class BookExchangeReadFull(BookExchangeRead): sender: \"UserBase\" = None receiver: \"UserBase\" = None book_instance: \"BookInstanceWithBook\" = None Endpointes user from fastapi import FastAPI, HTTPException, Depends, APIRouter from psycopg2._psycopg import List from sqlmodel import select from models import User, UserInput, UserBase, UserLogin, UserReadFull, UserPassword from auth.auth import AuthHandler from database.conn import get_session user_router = APIRouter() auth_handler = AuthHandler() @user_router.post('/register', status_code=201, description='Register new user') def register(user: UserInput, session=Depends(get_session)): users = session.exec(select(User)).all() if any(x.username == user.username for x in users): raise HTTPException(status_code=400, detail='Username is taken') if any(x.email == user.email for x in users): raise HTTPException(status_code=400, detail='Email is taken') hashed_pwd = auth_handler.get_password_hash(user.password) user = User(username=user.username, password=hashed_pwd, email=user.email, name=user.name, about=user.about) session.add(user) session.commit() return {\"status\": 201, \"message\": \"New user is created!\"} @user_router.get('/users') def get_users(session=Depends(get_session)) -> list[User]: users = session.exec(select(User)).all() return users @user_router.post('/login') def login(user: UserLogin, session=Depends(get_session)): user_found = session.exec(select(User).where(User.username == user.username)).first() if not user_found: raise HTTPException(status_code=401, detail='Invalid username or password') verified = auth_handler.verify_password(user.password, user_found.password) if not verified: raise HTTPException(status_code=401, detail='Invalid username or password') token = auth_handler.encode_token(user_found.username) return {'token': token} @user_router.get('/users/me') def get_current_user(user: User = Depends(auth_handler.get_current_user)) -> UserReadFull: return user @user_router.patch('/users/me/change-password') def change_password(passwords: UserPassword, user: User = Depends(auth_handler.get_current_user), session=Depends(get_session)): # \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u0447\u0442\u043e \u0442\u0435\u043a\u0443\u0449\u0438\u0439 \u043f\u0430\u0440\u043e\u043b\u044c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0432\u0435\u0440\u043d\u044b\u0439 if not auth_handler.verify_password(passwords.old_password, user.password): raise HTTPException(status_code=400, detail=\"Current password is incorrect\") # \u0425\u0435\u0448\u0438\u0440\u0443\u0435\u043c \u043d\u043e\u0432\u044b\u0439 \u043f\u0430\u0440\u043e\u043b\u044c hashed_new_password = auth_handler.get_password_hash(passwords.new_password) # \u041e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u043c \u043f\u0430\u0440\u043e\u043b\u044c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0432 \u0431\u0430\u0437\u0435 \u0434\u0430\u043d\u043d\u044b\u0445 user.password = hashed_new_password session.add(user) session.commit() return {\"message\": \"Password updated successfully\"} @user_router.get(\"/users/{user_id}\") def get_user_by_id(user_id: int, session=Depends(get_session)) -> UserReadFull: user = session.get(User, user_id) if not user: raise HTTPException(status_code=404, detail=\"User not found\") return user Register Login Get current user Get user by id Get all users Change password Database connection from sqlmodel import SQLModel, Session, create_engine import os from dotenv import load_dotenv load_dotenv() db_url = os.getenv(\"DB_URL\") engine = create_engine(db_url, echo=True) def init_db(): SQLModel.metadata.create_all(engine) def get_session(): with Session(engine) as session: yield session \u0425\u044d\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u043e\u043b\u0435\u0439, \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0438 \u0434\u0435\u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 JWT, \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0430\u0443\u043d\u0442\u0435\u0444\u0438\u043a\u0430\u0446\u0438\u0438, \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f import datetime from fastapi import Security, HTTPException, Depends from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials from passlib.context import CryptContext import jwt from starlette import status from database.conn import get_session from models import User from sqlmodel import select class AuthHandler: security = HTTPBearer() pwd_context = CryptContext(schemes=['bcrypt']) SECRET_KEY = 'SECRET_KEY' def get_password_hash(self, password): return self.pwd_context.hash(password) def verify_password(self, pwd, hashed_pwd): return self.pwd_context.verify(pwd, hashed_pwd) def encode_token(self, username): payload = { 'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=8), 'iat': datetime.datetime.utcnow(), 'sub': username } return jwt.encode(payload, self.SECRET_KEY, algorithm='HS256') def decode_token(self, token): try: payload = jwt.decode(token, self.SECRET_KEY, algorithms=['HS256']) return payload['sub'] except jwt.ExpiredSignatureError: raise HTTPException(status_code=401, detail='Expired signature') except jwt.InvalidTokenError: raise HTTPException(status_code=401, detail='Invalid token') def auth_wrapper(self, auth: HTTPAuthorizationCredentials = Security(security)): return self.decode_token(auth.credentials) def get_current_user(self, auth: HTTPAuthorizationCredentials = Security(security), session=Depends(get_session)): credentials_exception = HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail='Could not validate credentials' ) username = self.decode_token(auth.credentials) # \u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0438\u043c\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0438\u0437 \u0442\u043e\u043a\u0435\u043d\u0430 if username is None: raise credentials_exception user = session.exec(select(User).where(User.username == username)).first() # \u041d\u0430\u0439\u0442\u0438 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u043f\u043e \u0438\u043c\u0435\u043d\u0438 if user is None: raise credentials_exception return user","title":"LR1"},{"location":"LR1/#models","text":"","title":"Models"},{"location":"LR1/#book-instance","text":"class BookInstanceBase(SQLModel): book_id: Optional[int] = Field(default=None, foreign_key=\"book.id\") date: datetime.datetime publisher: str features: str class BookInstance(BookInstanceBase, table=True): id: int = Field(default=None, primary_key=True) owner_id: Optional[int] = Field(default=None, foreign_key=\"user.id\") requests: Optional[List[\"BookExchange\"]] = Relationship( back_populates=\"book_instance\", sa_relationship_kwargs=dict(foreign_keys=\"[BookExchange.book_instance_id]\"), ) book: Optional[\"Book\"] = Relationship(back_populates=\"instances\") owner: Optional[\"User\"] = Relationship(back_populates=\"instances\") class BookInstanceRead(BookInstanceBase): id: int owner_id: int class BookInstanceWithBook(BookInstanceRead): book: \"BookRead\" = None class BookInstanceReadFull(BookInstanceWithBook): requests: list[\"BookExchangeRead\"] = [] owner: \"UserBase\" = None","title":"Book instance"},{"location":"LR1/#author","text":"class AuthorBase(SQLModel): name: str bio: str class Author(AuthorBase, table=True): id: int = Field(default=None, primary_key=True) books: Optional[List[\"Book\"]] = Relationship(back_populates=\"author\") class AuthorRead(AuthorBase): id: int class AuthorReadFull(AuthorRead): books: list[\"BookRead\"] = []","title":"Author"},{"location":"LR1/#book","text":"class BookBase(SQLModel): title: str description: str author_id: Optional[int] = Field(default=None, foreign_key=\"author.id\") class Book(BookBase, table=True): id: int = Field(default=None, primary_key=True) author: Optional[Author] = Relationship(back_populates=\"books\") owners: Optional[List[\"User\"]] = Relationship(back_populates=\"books\", link_model=BookInstance) instances: Optional[List[\"BookInstance\"]] = Relationship(back_populates=\"book\") class BookRead(BookBase): id: int class BookReadFull(BookRead): author: AuthorRead = None owners: list[\"UserBase\"] = [] instances: list[\"BookInstanceRead\"] = []","title":"Book"},{"location":"LR1/#user","text":"class UserBase(SQLModel): id: int = Field(primary_key=True) username: str = Field(index=True) name: str about: str email: EmailStr = Field(unique=True, index=True, sa_type=AutoString) class User(UserBase, table=True): password: str = Field(max_length=256, min_length=6) created_at: datetime.datetime = datetime.datetime.now() books: Optional[List[\"Book\"]] = Relationship(back_populates=\"owners\", link_model=BookInstance) sender_requests: Optional[List[\"BookExchange\"]] = Relationship( back_populates=\"sender\", sa_relationship_kwargs=dict(foreign_keys=\"[BookExchange.sender_id]\"), ) receiver_requests: Optional[List[\"BookExchange\"]] = Relationship( back_populates=\"receiver\", sa_relationship_kwargs=dict(foreign_keys=\"[BookExchange.receiver_id]\"), ) instances: Optional[List[\"BookInstance\"]] = Relationship(back_populates=\"owner\") class UserReadFull(UserBase): sender_requests: list[\"BookExchangeRead\"] = [] receiver_requests: list[\"BookExchangeRead\"] = [] instances: list[\"BookInstanceWithBook\"] = [] class UserInput(SQLModel): name: str about: str username: str password: str = Field(max_length=256, min_length=6) password2: str email: EmailStr = Field(unique=True, index=True, sa_type=AutoString) @validator('password2') def password_match(cls, v, values, **kwargs): if 'password' in values and v != values['password']: raise ValueError('passwords don\\'t match') return v class UserLogin(SQLModel): username: str password: str class UserPassword(SQLModel): old_password: str new_password: str","title":"User"},{"location":"LR1/#book-exchange","text":"class BookExchangeBase(SQLModel): book_instance_id: Optional[int] = Field(default=None, foreign_key=\"bookinstance.id\") status: ExchangeStatus date_start: datetime.datetime date_end: datetime.datetime class BookExchange(BookExchangeBase, table=True): id: int = Field(default=None, primary_key=True) sender_id: Optional[int] = Field(default=None, foreign_key=\"user.id\") receiver_id: Optional[int] = Field(default=None, foreign_key=\"user.id\") sender: Optional[\"User\"] = Relationship( back_populates=\"sender_requests\", sa_relationship_kwargs=dict(foreign_keys=\"[BookExchange.sender_id]\"), ) receiver: Optional[\"User\"] = Relationship( back_populates=\"receiver_requests\", sa_relationship_kwargs=dict(foreign_keys=\"[BookExchange.receiver_id]\"), ) book_instance: Optional[\"BookInstance\"] = Relationship( back_populates=\"requests\", sa_relationship_kwargs=dict(foreign_keys=\"[BookExchange.book_instance_id]\"), ) class BookExchangeChangeStatus(SQLModel): status: ExchangeStatus class BookExchangeRead(BookExchangeBase): id: int sender_id: int receiver_id: int class BookExchangeReadFull(BookExchangeRead): sender: \"UserBase\" = None receiver: \"UserBase\" = None book_instance: \"BookInstanceWithBook\" = None","title":"Book exchange"},{"location":"LR1/#endpointes","text":"","title":"Endpointes"},{"location":"LR1/#user_1","text":"from fastapi import FastAPI, HTTPException, Depends, APIRouter from psycopg2._psycopg import List from sqlmodel import select from models import User, UserInput, UserBase, UserLogin, UserReadFull, UserPassword from auth.auth import AuthHandler from database.conn import get_session user_router = APIRouter() auth_handler = AuthHandler() @user_router.post('/register', status_code=201, description='Register new user') def register(user: UserInput, session=Depends(get_session)): users = session.exec(select(User)).all() if any(x.username == user.username for x in users): raise HTTPException(status_code=400, detail='Username is taken') if any(x.email == user.email for x in users): raise HTTPException(status_code=400, detail='Email is taken') hashed_pwd = auth_handler.get_password_hash(user.password) user = User(username=user.username, password=hashed_pwd, email=user.email, name=user.name, about=user.about) session.add(user) session.commit() return {\"status\": 201, \"message\": \"New user is created!\"} @user_router.get('/users') def get_users(session=Depends(get_session)) -> list[User]: users = session.exec(select(User)).all() return users @user_router.post('/login') def login(user: UserLogin, session=Depends(get_session)): user_found = session.exec(select(User).where(User.username == user.username)).first() if not user_found: raise HTTPException(status_code=401, detail='Invalid username or password') verified = auth_handler.verify_password(user.password, user_found.password) if not verified: raise HTTPException(status_code=401, detail='Invalid username or password') token = auth_handler.encode_token(user_found.username) return {'token': token} @user_router.get('/users/me') def get_current_user(user: User = Depends(auth_handler.get_current_user)) -> UserReadFull: return user @user_router.patch('/users/me/change-password') def change_password(passwords: UserPassword, user: User = Depends(auth_handler.get_current_user), session=Depends(get_session)): # \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u0447\u0442\u043e \u0442\u0435\u043a\u0443\u0449\u0438\u0439 \u043f\u0430\u0440\u043e\u043b\u044c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0432\u0435\u0440\u043d\u044b\u0439 if not auth_handler.verify_password(passwords.old_password, user.password): raise HTTPException(status_code=400, detail=\"Current password is incorrect\") # \u0425\u0435\u0448\u0438\u0440\u0443\u0435\u043c \u043d\u043e\u0432\u044b\u0439 \u043f\u0430\u0440\u043e\u043b\u044c hashed_new_password = auth_handler.get_password_hash(passwords.new_password) # \u041e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u043c \u043f\u0430\u0440\u043e\u043b\u044c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0432 \u0431\u0430\u0437\u0435 \u0434\u0430\u043d\u043d\u044b\u0445 user.password = hashed_new_password session.add(user) session.commit() return {\"message\": \"Password updated successfully\"} @user_router.get(\"/users/{user_id}\") def get_user_by_id(user_id: int, session=Depends(get_session)) -> UserReadFull: user = session.get(User, user_id) if not user: raise HTTPException(status_code=404, detail=\"User not found\") return user","title":"user"},{"location":"LR1/#register","text":"","title":"Register"},{"location":"LR1/#login","text":"","title":"Login"},{"location":"LR1/#get-current-user","text":"","title":"Get current user"},{"location":"LR1/#get-user-by-id","text":"","title":"Get user by id"},{"location":"LR1/#get-all-users","text":"","title":"Get all users"},{"location":"LR1/#change-password","text":"","title":"Change password"},{"location":"LR1/#database-connection","text":"from sqlmodel import SQLModel, Session, create_engine import os from dotenv import load_dotenv load_dotenv() db_url = os.getenv(\"DB_URL\") engine = create_engine(db_url, echo=True) def init_db(): SQLModel.metadata.create_all(engine) def get_session(): with Session(engine) as session: yield session","title":"Database connection"},{"location":"LR1/#jwt","text":"import datetime from fastapi import Security, HTTPException, Depends from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials from passlib.context import CryptContext import jwt from starlette import status from database.conn import get_session from models import User from sqlmodel import select class AuthHandler: security = HTTPBearer() pwd_context = CryptContext(schemes=['bcrypt']) SECRET_KEY = 'SECRET_KEY' def get_password_hash(self, password): return self.pwd_context.hash(password) def verify_password(self, pwd, hashed_pwd): return self.pwd_context.verify(pwd, hashed_pwd) def encode_token(self, username): payload = { 'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=8), 'iat': datetime.datetime.utcnow(), 'sub': username } return jwt.encode(payload, self.SECRET_KEY, algorithm='HS256') def decode_token(self, token): try: payload = jwt.decode(token, self.SECRET_KEY, algorithms=['HS256']) return payload['sub'] except jwt.ExpiredSignatureError: raise HTTPException(status_code=401, detail='Expired signature') except jwt.InvalidTokenError: raise HTTPException(status_code=401, detail='Invalid token') def auth_wrapper(self, auth: HTTPAuthorizationCredentials = Security(security)): return self.decode_token(auth.credentials) def get_current_user(self, auth: HTTPAuthorizationCredentials = Security(security), session=Depends(get_session)): credentials_exception = HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail='Could not validate credentials' ) username = self.decode_token(auth.credentials) # \u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0438\u043c\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0438\u0437 \u0442\u043e\u043a\u0435\u043d\u0430 if username is None: raise credentials_exception user = session.exec(select(User).where(User.username == username)).first() # \u041d\u0430\u0439\u0442\u0438 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u043f\u043e \u0438\u043c\u0435\u043d\u0438 if user is None: raise credentials_exception return user","title":"\u0425\u044d\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u043e\u043b\u0435\u0439, \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0438 \u0434\u0435\u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 JWT, \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0430\u0443\u043d\u0442\u0435\u0444\u0438\u043a\u0430\u0446\u0438\u0438, \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f"},{"location":"PR1/","text":"Models from enum import Enum from typing import Optional, List from pydantic import BaseModel class Profession(BaseModel): id: int title: str description: str class Skill(BaseModel): id: int name: str description: str class RaceType(Enum): director = \"director\" worker = \"worker\" junior = \"junior\" class Warrior(BaseModel): id: int race: RaceType name: str level: int profession: Profession skills: Optional[List[Skill]] = [] db.py temp_bd = [ { \"id\": 1, \"race\": \"director\", \"name\": \"\u0421\u0442\u0430\u0440\u043e\u0432\u043e\u0439\u0442\u043e\u0432\u0430 \u041b\u0438\u0437\u0430\", \"level\": 12, \"profession\": { \"id\": 2, \"title\": \"\u0421\u0442\u0430\u0440\u0448\u0430\u044f \u0441\u0435\u0441\u0442\u0440\u0430\", \"description\": \"\u0413\u043b\u0430\u0432\u043d\u0430\u044f \u0438\u0437 \u0441\u0435\u0441\u0442\u0435\u0440\", }, }, { \"id\": 2, \"race\": \"worker\", \"name\": \"\u0421\u0442\u0430\u0440\u043e\u0432\u043e\u0439\u0442\u043e\u0432\u0430 \u041a\u0430\u0442\u044f\", \"level\": 12, \"profession\": { \"id\": 1, \"title\": \"\u041c\u043b\u0430\u0434\u0448\u0430\u044f \u0441\u0435\u0441\u0442\u0440\u0430\", \"description\": \"\u041c\u043b\u0430\u0434\u0448\u0435 \u043d\u0430 5 \u043c\u0438\u043d\u0443\u0442\", }, }, ] db_professions = [ {\"id\": 1, \"title\": \"\u0421\u0442\u0430\u0440\u0448\u0430\u044f \u0441\u0435\u0441\u0442\u0440\u0430\", \"description\": \"\u0413\u043b\u0430\u0432\u043d\u0430\u044f \u0438\u0437 \u0441\u0435\u0441\u0442\u0435\u0440\"}, { \"id\": 2, \"title\": \"\u041c\u043b\u0430\u0434\u0448\u0430\u044f \u0441\u0435\u0441\u0442\u0440\u0430\", \"description\": \"\u041c\u043b\u0430\u0434\u0448\u0435 \u043d\u0430 5 \u043c\u0438\u043d\u0443\u0442\", }, ] Main.py import uvicorn from fastapi import FastAPI, HTTPException from typing_extensions import List, TypedDict import db import models app = FastAPI() warior_create_response = TypedDict(\"Response\", {\"status\": int, \"data\": models.Warrior}) @app.get(\"/warriors_list\") def warriors_list() -> List[models.Warrior]: return db.temp_bd @app.get(\"/warrior/{warrior_id}\") def warriors_get(warrior_id: int) -> List[models.Warrior]: return [warrior for warrior in db.temp_bd if warrior.get(\"id\") == warrior_id] @app.post(\"/warrior\") def warriors_create( warrior: models.Warrior, ) -> warior_create_response: warrior_to_append = warrior.model_dump() db.temp_bd.append(warrior_to_append) return {\"status\": 200, \"data\": warrior} @app.delete(\"/warrior/delete{warrior_id}\") def warrior_delete(warrior_id: int): for i, warrior in enumerate(db.temp_bd): if warrior.get(\"id\") == warrior_id: db.temp_bd.pop(i) break return {\"status\": 201, \"message\": \"deleted\"} @app.put(\"/warrior{warrior_id}\") def warrior_update(warrior_id: int, warrior: models.Warrior) -> List[models.Warrior]: for war in db.temp_bd: if war.get(\"id\") == warrior_id: warrior_to_append = warrior.model_dump() db.temp_bd.remove(war) db.temp_bd.append(warrior_to_append) return db.temp_bd @app.post(\"/professions/\") async def create_profession(profession: models.Profession): profession_dict = profession.dict() profession_dict[\"id\"] = len(db.db_professions) + 1 db.db_professions.append(profession_dict) return profession_dict @app.get(\"/professions/\", response_model=List[models.Profession]) async def read_professions(): return db.db_professions @app.get(\"/professions/{profession_id}\", response_model=models.Profession) async def read_profession(profession_id: int): for profession in db.db_professions: if profession[\"id\"] == profession_id: return profession raise HTTPException(status_code=404, detail=\"Profession not found\") @app.put(\"/professions/{profession_id}\") async def update_profession(profession_id: int, profession: models.Profession): for index, prof in enumerate(db.db_professions): if prof[\"id\"] == profession_id: update_profession_dict = profession.dict() update_profession_dict[\"id\"] = profession_id db.db_professions[index] = update_profession_dict return update_profession_dict raise HTTPException(status_code=404, detail=\"Profession not found\") @app.delete(\"/professions/{profession_id}\") async def delete_profession(profession_id: int): for index, profession in enumerate(db.db_professions): if profession[\"id\"] == profession_id: del db.db_professions[index] return {\"message\": \"Profession deleted successfully\"} raise HTTPException(status_code=404, detail=\"Profession not found\") if __name__ == '__main__': uvicorn.run('main:app', host=\"localhost\", port=8000, reload=True)","title":"PR1"},{"location":"PR1/#models","text":"from enum import Enum from typing import Optional, List from pydantic import BaseModel class Profession(BaseModel): id: int title: str description: str class Skill(BaseModel): id: int name: str description: str class RaceType(Enum): director = \"director\" worker = \"worker\" junior = \"junior\" class Warrior(BaseModel): id: int race: RaceType name: str level: int profession: Profession skills: Optional[List[Skill]] = []","title":"Models"},{"location":"PR1/#dbpy","text":"temp_bd = [ { \"id\": 1, \"race\": \"director\", \"name\": \"\u0421\u0442\u0430\u0440\u043e\u0432\u043e\u0439\u0442\u043e\u0432\u0430 \u041b\u0438\u0437\u0430\", \"level\": 12, \"profession\": { \"id\": 2, \"title\": \"\u0421\u0442\u0430\u0440\u0448\u0430\u044f \u0441\u0435\u0441\u0442\u0440\u0430\", \"description\": \"\u0413\u043b\u0430\u0432\u043d\u0430\u044f \u0438\u0437 \u0441\u0435\u0441\u0442\u0435\u0440\", }, }, { \"id\": 2, \"race\": \"worker\", \"name\": \"\u0421\u0442\u0430\u0440\u043e\u0432\u043e\u0439\u0442\u043e\u0432\u0430 \u041a\u0430\u0442\u044f\", \"level\": 12, \"profession\": { \"id\": 1, \"title\": \"\u041c\u043b\u0430\u0434\u0448\u0430\u044f \u0441\u0435\u0441\u0442\u0440\u0430\", \"description\": \"\u041c\u043b\u0430\u0434\u0448\u0435 \u043d\u0430 5 \u043c\u0438\u043d\u0443\u0442\", }, }, ] db_professions = [ {\"id\": 1, \"title\": \"\u0421\u0442\u0430\u0440\u0448\u0430\u044f \u0441\u0435\u0441\u0442\u0440\u0430\", \"description\": \"\u0413\u043b\u0430\u0432\u043d\u0430\u044f \u0438\u0437 \u0441\u0435\u0441\u0442\u0435\u0440\"}, { \"id\": 2, \"title\": \"\u041c\u043b\u0430\u0434\u0448\u0430\u044f \u0441\u0435\u0441\u0442\u0440\u0430\", \"description\": \"\u041c\u043b\u0430\u0434\u0448\u0435 \u043d\u0430 5 \u043c\u0438\u043d\u0443\u0442\", }, ]","title":"db.py"},{"location":"PR1/#mainpy","text":"import uvicorn from fastapi import FastAPI, HTTPException from typing_extensions import List, TypedDict import db import models app = FastAPI() warior_create_response = TypedDict(\"Response\", {\"status\": int, \"data\": models.Warrior}) @app.get(\"/warriors_list\") def warriors_list() -> List[models.Warrior]: return db.temp_bd @app.get(\"/warrior/{warrior_id}\") def warriors_get(warrior_id: int) -> List[models.Warrior]: return [warrior for warrior in db.temp_bd if warrior.get(\"id\") == warrior_id] @app.post(\"/warrior\") def warriors_create( warrior: models.Warrior, ) -> warior_create_response: warrior_to_append = warrior.model_dump() db.temp_bd.append(warrior_to_append) return {\"status\": 200, \"data\": warrior} @app.delete(\"/warrior/delete{warrior_id}\") def warrior_delete(warrior_id: int): for i, warrior in enumerate(db.temp_bd): if warrior.get(\"id\") == warrior_id: db.temp_bd.pop(i) break return {\"status\": 201, \"message\": \"deleted\"} @app.put(\"/warrior{warrior_id}\") def warrior_update(warrior_id: int, warrior: models.Warrior) -> List[models.Warrior]: for war in db.temp_bd: if war.get(\"id\") == warrior_id: warrior_to_append = warrior.model_dump() db.temp_bd.remove(war) db.temp_bd.append(warrior_to_append) return db.temp_bd @app.post(\"/professions/\") async def create_profession(profession: models.Profession): profession_dict = profession.dict() profession_dict[\"id\"] = len(db.db_professions) + 1 db.db_professions.append(profession_dict) return profession_dict @app.get(\"/professions/\", response_model=List[models.Profession]) async def read_professions(): return db.db_professions @app.get(\"/professions/{profession_id}\", response_model=models.Profession) async def read_profession(profession_id: int): for profession in db.db_professions: if profession[\"id\"] == profession_id: return profession raise HTTPException(status_code=404, detail=\"Profession not found\") @app.put(\"/professions/{profession_id}\") async def update_profession(profession_id: int, profession: models.Profession): for index, prof in enumerate(db.db_professions): if prof[\"id\"] == profession_id: update_profession_dict = profession.dict() update_profession_dict[\"id\"] = profession_id db.db_professions[index] = update_profession_dict return update_profession_dict raise HTTPException(status_code=404, detail=\"Profession not found\") @app.delete(\"/professions/{profession_id}\") async def delete_profession(profession_id: int): for index, profession in enumerate(db.db_professions): if profession[\"id\"] == profession_id: del db.db_professions[index] return {\"message\": \"Profession deleted successfully\"} raise HTTPException(status_code=404, detail=\"Profession not found\") if __name__ == '__main__': uvicorn.run('main:app', host=\"localhost\", port=8000, reload=True)","title":"Main.py"},{"location":"PR2/","text":"Models from enum import Enum from typing import Optional, List from sqlmodel import SQLModel, Field, Relationship class RaceType(Enum): director = \"director\" worker = \"worker\" junior = \"junior\" class SkillWarriorLink(SQLModel, table=True): skill_id: Optional[int] = Field( default=None, foreign_key=\"skill.id\", primary_key=True ) warrior_id: Optional[int] = Field( default=None, foreign_key=\"warrior.id\", primary_key=True ) class SkillDefault(SQLModel): name: str description: Optional[str] = \"\" class Skill(SkillDefault, table=True): id: int = Field(default=None, primary_key=True) warriors: Optional[List[\"Warrior\"]] = Relationship( back_populates=\"skills\", link_model=SkillWarriorLink ) class ProfessionDefault(SQLModel): title: str description: str class Profession(ProfessionDefault, table=True): id: int = Field(default=None, primary_key=True) warriors_prof: List[\"Warrior\"] = Relationship(back_populates=\"profession\") class WarriorDefault(SQLModel): race: RaceType name: str level: int profession_id: Optional[int] = Field(default=None, foreign_key=\"profession.id\") class WarriorProfessions(WarriorDefault): profession: Optional[Profession] = None skills: Optional[List[Skill]] = None class Warrior(WarriorDefault, table=True): id: int = Field(default=None, primary_key=True) profession: Optional[Profession] = Relationship(back_populates=\"warriors_prof\") skills: Optional[List[Skill]] = Relationship( back_populates=\"warriors\", link_model=SkillWarriorLink ) db.py from sqlmodel import SQLModel, Session, create_engine db_url = 'postgresql://postgres:123@localhost/warriors_db' engine = create_engine(db_url, echo=True) def init_db(): SQLModel.metadata.create_all(engine) def get_session(): with Session(engine) as session: yield session main.py from sqlmodel import Session, select import uvicorn from fastapi import FastAPI, Depends, HTTPException from typing_extensions import List, TypedDict import db import models app = FastAPI() @app.on_event(\"startup\") def on_startup(): db.init_db() @app.get(\"/ping\") def ping(): return \"pong\" create_warrior_response = TypedDict(\"Response\", {\"status\": int, \"data\": models.Warrior}) @app.post(\"/warrior\") def warriors_create( warrior: models.WarriorDefault, session=Depends(db.get_session) ) -> create_warrior_response: warrior = models.Warrior.model_validate(warrior) session.add(warrior) session.commit() session.refresh(warrior) return {\"status\": 200, \"data\": warrior} @app.get(\"/warriors_list\") def warriors_list(session=Depends(db.get_session)) -> List[models.Warrior]: return session.exec(select(models.Warrior)).all() @app.get(\"/warrior/{warrior_id}\") def warriors_get(warrior_id: int, session=Depends(db.get_session)) -> models.WarriorProfessions: warrior = session.get(models.Warrior, warrior_id) return warrior @app.patch(\"/warrior/{warrior_id}\") def warrior_update( warrior_id: int, warrior: models.WarriorDefault, session=Depends(db.get_session) ) -> models.WarriorDefault: db_warrior = session.get(models.Warrior, warrior_id) if not db_warrior: raise HTTPException(status_code=404, detail=\"Warrior not found\") warrior_data = warrior.model_dump(exclude_unset=True) for key, value in warrior_data.items(): setattr(db_warrior, key, value) session.add(db_warrior) session.commit() session.refresh(db_warrior) return db_warrior @app.delete(\"/warrior/delete{warrior_id}\") def warrior_delete(warrior_id: int, session=Depends(db.get_session)): warrior = session.get(models.Warrior, warrior_id) if not warrior: raise HTTPException(status_code=404, detail=\"Warrior not found\") session.delete(warrior) session.commit() return {\"ok\": True} @app.get(\"/professions_list\") def professions_list(session=Depends(db.get_session)) -> List[models.Profession]: return session.exec(select(models.Profession)).all() @app.get(\"/profession/{profession_id}\") def profession_get( profession_id: int, session: Session = Depends(db.get_session) ) -> models.Profession: return session.get(models.Profession, profession_id) create_profession_response = TypedDict( \"Response\", {\"status\": int, \"data\": models.Profession} ) @app.post(\"/profession\") def profession_create( prof: models.ProfessionDefault, session: Session = Depends(db.get_session) ) -> create_profession_response: prof = models.Profession.model_validate(prof) session.add(prof) session.commit() session.refresh(prof) return {\"status\": 200, \"data\": prof} @app.post(\"/skills/\") def create_skill( skill: models.SkillDefault, session: Session = Depends(db.get_session) ): skill = models.Skill.model_validate(skill) session.add(skill) session.commit() session.refresh(skill) return {\"status\": 200, \"data\": skill} @app.get(\"/skills/{skill_id}\") def read_skill(skill_id: int, session: Session = Depends(db.get_session)): skill = session.get(models.Skill, skill_id) if skill is None: raise HTTPException(status_code=404, detail=\"Skill not found\") return skill @app.patch(\"/skills/{skill_id}\") def update_skill( skill_id: int, skill: models.SkillDefault, session: Session = Depends(db.init_db) ): db_skill = session.get(models.Skill, skill_id) if db_skill is None: raise HTTPException(status_code=404, detail=\"Skill not found\") skill_data = skill.model_dump(exclude_unset=True) for key, value in skill_data.items(): setattr(db_skill, key, value) session.add(db_skill) session.commit() session.refresh(db_skill) return db_skill @app.delete(\"/skills/{skill_id}\") def skill_delete(skill_id: int, session: Session = Depends(db.get_session)): skill = session.get(models.Skill, skill_id) if not skill: raise HTTPException(status_code=404, detail=\"Skill not found\") session.delete(skill) session.commit() return {\"ok\": True} if __name__ == '__main__': uvicorn.run('main:app', host=\"localhost\", port=8000, reload=True)","title":"PR2"},{"location":"PR2/#models","text":"from enum import Enum from typing import Optional, List from sqlmodel import SQLModel, Field, Relationship class RaceType(Enum): director = \"director\" worker = \"worker\" junior = \"junior\" class SkillWarriorLink(SQLModel, table=True): skill_id: Optional[int] = Field( default=None, foreign_key=\"skill.id\", primary_key=True ) warrior_id: Optional[int] = Field( default=None, foreign_key=\"warrior.id\", primary_key=True ) class SkillDefault(SQLModel): name: str description: Optional[str] = \"\" class Skill(SkillDefault, table=True): id: int = Field(default=None, primary_key=True) warriors: Optional[List[\"Warrior\"]] = Relationship( back_populates=\"skills\", link_model=SkillWarriorLink ) class ProfessionDefault(SQLModel): title: str description: str class Profession(ProfessionDefault, table=True): id: int = Field(default=None, primary_key=True) warriors_prof: List[\"Warrior\"] = Relationship(back_populates=\"profession\") class WarriorDefault(SQLModel): race: RaceType name: str level: int profession_id: Optional[int] = Field(default=None, foreign_key=\"profession.id\") class WarriorProfessions(WarriorDefault): profession: Optional[Profession] = None skills: Optional[List[Skill]] = None class Warrior(WarriorDefault, table=True): id: int = Field(default=None, primary_key=True) profession: Optional[Profession] = Relationship(back_populates=\"warriors_prof\") skills: Optional[List[Skill]] = Relationship( back_populates=\"warriors\", link_model=SkillWarriorLink )","title":"Models"},{"location":"PR2/#dbpy","text":"from sqlmodel import SQLModel, Session, create_engine db_url = 'postgresql://postgres:123@localhost/warriors_db' engine = create_engine(db_url, echo=True) def init_db(): SQLModel.metadata.create_all(engine) def get_session(): with Session(engine) as session: yield session","title":"db.py"},{"location":"PR2/#mainpy","text":"from sqlmodel import Session, select import uvicorn from fastapi import FastAPI, Depends, HTTPException from typing_extensions import List, TypedDict import db import models app = FastAPI() @app.on_event(\"startup\") def on_startup(): db.init_db() @app.get(\"/ping\") def ping(): return \"pong\" create_warrior_response = TypedDict(\"Response\", {\"status\": int, \"data\": models.Warrior}) @app.post(\"/warrior\") def warriors_create( warrior: models.WarriorDefault, session=Depends(db.get_session) ) -> create_warrior_response: warrior = models.Warrior.model_validate(warrior) session.add(warrior) session.commit() session.refresh(warrior) return {\"status\": 200, \"data\": warrior} @app.get(\"/warriors_list\") def warriors_list(session=Depends(db.get_session)) -> List[models.Warrior]: return session.exec(select(models.Warrior)).all() @app.get(\"/warrior/{warrior_id}\") def warriors_get(warrior_id: int, session=Depends(db.get_session)) -> models.WarriorProfessions: warrior = session.get(models.Warrior, warrior_id) return warrior @app.patch(\"/warrior/{warrior_id}\") def warrior_update( warrior_id: int, warrior: models.WarriorDefault, session=Depends(db.get_session) ) -> models.WarriorDefault: db_warrior = session.get(models.Warrior, warrior_id) if not db_warrior: raise HTTPException(status_code=404, detail=\"Warrior not found\") warrior_data = warrior.model_dump(exclude_unset=True) for key, value in warrior_data.items(): setattr(db_warrior, key, value) session.add(db_warrior) session.commit() session.refresh(db_warrior) return db_warrior @app.delete(\"/warrior/delete{warrior_id}\") def warrior_delete(warrior_id: int, session=Depends(db.get_session)): warrior = session.get(models.Warrior, warrior_id) if not warrior: raise HTTPException(status_code=404, detail=\"Warrior not found\") session.delete(warrior) session.commit() return {\"ok\": True} @app.get(\"/professions_list\") def professions_list(session=Depends(db.get_session)) -> List[models.Profession]: return session.exec(select(models.Profession)).all() @app.get(\"/profession/{profession_id}\") def profession_get( profession_id: int, session: Session = Depends(db.get_session) ) -> models.Profession: return session.get(models.Profession, profession_id) create_profession_response = TypedDict( \"Response\", {\"status\": int, \"data\": models.Profession} ) @app.post(\"/profession\") def profession_create( prof: models.ProfessionDefault, session: Session = Depends(db.get_session) ) -> create_profession_response: prof = models.Profession.model_validate(prof) session.add(prof) session.commit() session.refresh(prof) return {\"status\": 200, \"data\": prof} @app.post(\"/skills/\") def create_skill( skill: models.SkillDefault, session: Session = Depends(db.get_session) ): skill = models.Skill.model_validate(skill) session.add(skill) session.commit() session.refresh(skill) return {\"status\": 200, \"data\": skill} @app.get(\"/skills/{skill_id}\") def read_skill(skill_id: int, session: Session = Depends(db.get_session)): skill = session.get(models.Skill, skill_id) if skill is None: raise HTTPException(status_code=404, detail=\"Skill not found\") return skill @app.patch(\"/skills/{skill_id}\") def update_skill( skill_id: int, skill: models.SkillDefault, session: Session = Depends(db.init_db) ): db_skill = session.get(models.Skill, skill_id) if db_skill is None: raise HTTPException(status_code=404, detail=\"Skill not found\") skill_data = skill.model_dump(exclude_unset=True) for key, value in skill_data.items(): setattr(db_skill, key, value) session.add(db_skill) session.commit() session.refresh(db_skill) return db_skill @app.delete(\"/skills/{skill_id}\") def skill_delete(skill_id: int, session: Session = Depends(db.get_session)): skill = session.get(models.Skill, skill_id) if not skill: raise HTTPException(status_code=404, detail=\"Skill not found\") session.delete(skill) session.commit() return {\"ok\": True} if __name__ == '__main__': uvicorn.run('main:app', host=\"localhost\", port=8000, reload=True)","title":"main.py"},{"location":"PR3/","text":"Models from enum import Enum from typing import Optional, List from sqlmodel import SQLModel, Field, Relationship class RaceType(Enum): director = \"director\" worker = \"worker\" junior = \"junior\" class SkillWarriorLink(SQLModel, table=True): skill_id: Optional[int] = Field( default=None, foreign_key=\"skill.id\", primary_key=True ) warrior_id: Optional[int] = Field( default=None, foreign_key=\"warrior.id\", primary_key=True ) level: int class SkillDefault(SQLModel): name: str description: Optional[str] = \"\" class Skill(SkillDefault, table=True): id: int = Field(default=None, primary_key=True) warriors: Optional[List[\"Warrior\"]] = Relationship( back_populates=\"skills\", link_model=SkillWarriorLink ) class ProfessionDefault(SQLModel): title: str description: str class Profession(ProfessionDefault, table=True): id: int = Field(default=None, primary_key=True) warriors_prof: List[\"Warrior\"] = Relationship(back_populates=\"profession\") class WarriorDefault(SQLModel): race: RaceType name: str level: int profession_id: Optional[int] = Field(default=None, foreign_key=\"profession.id\") class WarriorProfessions(WarriorDefault): profession: Optional[Profession] = None skills: Optional[List[Skill]] = None class Warrior(WarriorDefault, table=True): id: int = Field(default=None, primary_key=True) profession: Optional[Profession] = Relationship(back_populates=\"warriors_prof\") skills: Optional[List[Skill]] = Relationship( back_populates=\"warriors\", link_model=SkillWarriorLink ) database connection from sqlmodel import SQLModel, Session, create_engine from dotenv import load_dotenv import os load_dotenv() db_url = os.getenv(\"DB_URL\") engine = create_engine(db_url, echo=True) def init_db(): SQLModel.metadata.create_all(engine) def get_session(): with Session(engine) as session: yield session main.py from sqlmodel import Session, select import uvicorn from fastapi import FastAPI, Depends, HTTPException from typing_extensions import List, TypedDict import db import models app = FastAPI() @app.on_event(\"startup\") def on_startup(): db.init_db() @app.get(\"/ping\") def ping(): return \"pong\" create_warrior_response = TypedDict(\"Response\", {\"status\": int, \"data\": models.Warrior}) @app.post(\"/warrior\") def warriors_create( warrior: models.WarriorDefault, session=Depends(db.get_session) ) -> create_warrior_response: warrior = models.Warrior.model_validate(warrior) session.add(warrior) session.commit() session.refresh(warrior) return {\"status\": 200, \"data\": warrior} @app.get(\"/warriors_list\") def warriors_list(session=Depends(db.get_session)) -> List[models.Warrior]: return session.exec(select(models.Warrior)).all() @app.get(\"/warrior/{warrior_id}\") def warriors_get(warrior_id: int, session=Depends(db.get_session)) -> models.WarriorProfessions: warrior = session.get(models.Warrior, warrior_id) return warrior @app.patch(\"/warrior/{warrior_id}\") def warrior_update( warrior_id: int, warrior: models.WarriorDefault, session=Depends(db.get_session) ) -> models.WarriorDefault: db_warrior = session.get(models.Warrior, warrior_id) if not db_warrior: raise HTTPException(status_code=404, detail=\"Warrior not found\") warrior_data = warrior.model_dump(exclude_unset=True) for key, value in warrior_data.items(): setattr(db_warrior, key, value) session.add(db_warrior) session.commit() session.refresh(db_warrior) return db_warrior @app.delete(\"/warrior/delete{warrior_id}\") def warrior_delete(warrior_id: int, session=Depends(db.get_session)): warrior = session.get(models.Warrior, warrior_id) if not warrior: raise HTTPException(status_code=404, detail=\"Warrior not found\") session.delete(warrior) session.commit() return {\"ok\": True} @app.get(\"/professions_list\") def professions_list(session=Depends(db.get_session)) -> List[models.Profession]: return session.exec(select(models.Profession)).all() @app.get(\"/profession/{profession_id}\") def profession_get( profession_id: int, session: Session = Depends(db.get_session) ) -> models.Profession: return session.get(models.Profession, profession_id) create_profession_response = TypedDict( \"Response\", {\"status\": int, \"data\": models.Profession} ) @app.post(\"/profession\") def profession_create( prof: models.ProfessionDefault, session: Session = Depends(db.get_session) ) -> create_profession_response: prof = models.Profession.model_validate(prof) session.add(prof) session.commit() session.refresh(prof) return {\"status\": 200, \"data\": prof} @app.post(\"/skills/\") def create_skill( skill: models.SkillDefault, session: Session = Depends(db.get_session) ): skill = models.Skill.model_validate(skill) session.add(skill) session.commit() session.refresh(skill) return {\"status\": 200, \"data\": skill} @app.get(\"/skills/{skill_id}\") def read_skill(skill_id: int, session: Session = Depends(db.get_session)): skill = session.get(models.Skill, skill_id) if skill is None: raise HTTPException(status_code=404, detail=\"Skill not found\") return skill @app.patch(\"/skills/{skill_id}\") def update_skill( skill_id: int, skill: models.SkillDefault, session: Session = Depends(db.init_db) ): db_skill = session.get(models.Skill, skill_id) if db_skill is None: raise HTTPException(status_code=404, detail=\"Skill not found\") skill_data = skill.model_dump(exclude_unset=True) for key, value in skill_data.items(): setattr(db_skill, key, value) session.add(db_skill) session.commit() session.refresh(db_skill) return db_skill @app.delete(\"/skills/{skill_id}\") def skill_delete(skill_id: int, session: Session = Depends(db.get_session)): skill = session.get(models.Skill, skill_id) if not skill: raise HTTPException(status_code=404, detail=\"Skill not found\") session.delete(skill) session.commit() return {\"ok\": True} if __name__ == '__main__': uvicorn.run('main:app', host=\"localhost\", port=8000, reload=True)","title":"PR3"},{"location":"PR3/#models","text":"from enum import Enum from typing import Optional, List from sqlmodel import SQLModel, Field, Relationship class RaceType(Enum): director = \"director\" worker = \"worker\" junior = \"junior\" class SkillWarriorLink(SQLModel, table=True): skill_id: Optional[int] = Field( default=None, foreign_key=\"skill.id\", primary_key=True ) warrior_id: Optional[int] = Field( default=None, foreign_key=\"warrior.id\", primary_key=True ) level: int class SkillDefault(SQLModel): name: str description: Optional[str] = \"\" class Skill(SkillDefault, table=True): id: int = Field(default=None, primary_key=True) warriors: Optional[List[\"Warrior\"]] = Relationship( back_populates=\"skills\", link_model=SkillWarriorLink ) class ProfessionDefault(SQLModel): title: str description: str class Profession(ProfessionDefault, table=True): id: int = Field(default=None, primary_key=True) warriors_prof: List[\"Warrior\"] = Relationship(back_populates=\"profession\") class WarriorDefault(SQLModel): race: RaceType name: str level: int profession_id: Optional[int] = Field(default=None, foreign_key=\"profession.id\") class WarriorProfessions(WarriorDefault): profession: Optional[Profession] = None skills: Optional[List[Skill]] = None class Warrior(WarriorDefault, table=True): id: int = Field(default=None, primary_key=True) profession: Optional[Profession] = Relationship(back_populates=\"warriors_prof\") skills: Optional[List[Skill]] = Relationship( back_populates=\"warriors\", link_model=SkillWarriorLink )","title":"Models"},{"location":"PR3/#database-connection","text":"from sqlmodel import SQLModel, Session, create_engine from dotenv import load_dotenv import os load_dotenv() db_url = os.getenv(\"DB_URL\") engine = create_engine(db_url, echo=True) def init_db(): SQLModel.metadata.create_all(engine) def get_session(): with Session(engine) as session: yield session","title":"database connection"},{"location":"PR3/#mainpy","text":"from sqlmodel import Session, select import uvicorn from fastapi import FastAPI, Depends, HTTPException from typing_extensions import List, TypedDict import db import models app = FastAPI() @app.on_event(\"startup\") def on_startup(): db.init_db() @app.get(\"/ping\") def ping(): return \"pong\" create_warrior_response = TypedDict(\"Response\", {\"status\": int, \"data\": models.Warrior}) @app.post(\"/warrior\") def warriors_create( warrior: models.WarriorDefault, session=Depends(db.get_session) ) -> create_warrior_response: warrior = models.Warrior.model_validate(warrior) session.add(warrior) session.commit() session.refresh(warrior) return {\"status\": 200, \"data\": warrior} @app.get(\"/warriors_list\") def warriors_list(session=Depends(db.get_session)) -> List[models.Warrior]: return session.exec(select(models.Warrior)).all() @app.get(\"/warrior/{warrior_id}\") def warriors_get(warrior_id: int, session=Depends(db.get_session)) -> models.WarriorProfessions: warrior = session.get(models.Warrior, warrior_id) return warrior @app.patch(\"/warrior/{warrior_id}\") def warrior_update( warrior_id: int, warrior: models.WarriorDefault, session=Depends(db.get_session) ) -> models.WarriorDefault: db_warrior = session.get(models.Warrior, warrior_id) if not db_warrior: raise HTTPException(status_code=404, detail=\"Warrior not found\") warrior_data = warrior.model_dump(exclude_unset=True) for key, value in warrior_data.items(): setattr(db_warrior, key, value) session.add(db_warrior) session.commit() session.refresh(db_warrior) return db_warrior @app.delete(\"/warrior/delete{warrior_id}\") def warrior_delete(warrior_id: int, session=Depends(db.get_session)): warrior = session.get(models.Warrior, warrior_id) if not warrior: raise HTTPException(status_code=404, detail=\"Warrior not found\") session.delete(warrior) session.commit() return {\"ok\": True} @app.get(\"/professions_list\") def professions_list(session=Depends(db.get_session)) -> List[models.Profession]: return session.exec(select(models.Profession)).all() @app.get(\"/profession/{profession_id}\") def profession_get( profession_id: int, session: Session = Depends(db.get_session) ) -> models.Profession: return session.get(models.Profession, profession_id) create_profession_response = TypedDict( \"Response\", {\"status\": int, \"data\": models.Profession} ) @app.post(\"/profession\") def profession_create( prof: models.ProfessionDefault, session: Session = Depends(db.get_session) ) -> create_profession_response: prof = models.Profession.model_validate(prof) session.add(prof) session.commit() session.refresh(prof) return {\"status\": 200, \"data\": prof} @app.post(\"/skills/\") def create_skill( skill: models.SkillDefault, session: Session = Depends(db.get_session) ): skill = models.Skill.model_validate(skill) session.add(skill) session.commit() session.refresh(skill) return {\"status\": 200, \"data\": skill} @app.get(\"/skills/{skill_id}\") def read_skill(skill_id: int, session: Session = Depends(db.get_session)): skill = session.get(models.Skill, skill_id) if skill is None: raise HTTPException(status_code=404, detail=\"Skill not found\") return skill @app.patch(\"/skills/{skill_id}\") def update_skill( skill_id: int, skill: models.SkillDefault, session: Session = Depends(db.init_db) ): db_skill = session.get(models.Skill, skill_id) if db_skill is None: raise HTTPException(status_code=404, detail=\"Skill not found\") skill_data = skill.model_dump(exclude_unset=True) for key, value in skill_data.items(): setattr(db_skill, key, value) session.add(db_skill) session.commit() session.refresh(db_skill) return db_skill @app.delete(\"/skills/{skill_id}\") def skill_delete(skill_id: int, session: Session = Depends(db.get_session)): skill = session.get(models.Skill, skill_id) if not skill: raise HTTPException(status_code=404, detail=\"Skill not found\") session.delete(skill) session.commit() return {\"ok\": True} if __name__ == '__main__': uvicorn.run('main:app', host=\"localhost\", port=8000, reload=True)","title":"main.py"}]}